use cfg::Cfg;
use cfg_load::CfgLoadExt;

pub fn grammar() -> Cfg {
    Cfg::load(r##"
start ::= translation_unit;
primary_expression ::= identifier;
primary_expression ::= constant;
primary_expression ::= string_literal;
primary_expression ::= lparen expression rparen;
postfix_expression ::= primary_expression;
postfix_expression ::= postfix_expression lbracket expression rbracket;
postfix_expression ::= postfix_expression lparen argument_expression_list_opt rparen;
postfix_expression ::= postfix_expression dot identifier;
postfix_expression ::= postfix_expression ptr_op identifier;
postfix_expression ::= postfix_expression inc_op;
postfix_expression ::= postfix_expression dec_op;
postfix_expression ::= lparen type_name rparen lbrace initializer_list rbrace;
postfix_expression ::= lparen type_name rparen lbrace initializer_list comma rbrace;
argument_expression_list_opt ::= ;
argument_expression_list_opt ::= argument_expression_list;
argument_expression_list ::= assignment_expression;
argument_expression_list ::= argument_expression_list comma assignment_expression;
unary_expression ::= postfix_expression;
unary_expression ::= inc_op unary_expression;
unary_expression ::= dec_op unary_expression;
unary_expression ::= unary_operator cast_expression;
unary_expression ::= sizeof_ unary_expression;
unary_expression ::= sizeof_ lparen type_name rparen;
unary_operator ::= ampersand;
unary_operator ::= star;
unary_operator ::= plus;
unary_operator ::= minus;
unary_operator ::= tilde;
unary_operator ::= exclamation;
cast_expression ::= unary_expression;
cast_expression ::= lparen type_name rparen cast_expression;
multiplicative_expression ::= cast_expression;
multiplicative_expression ::= multiplicative_expression star cast_expression;
multiplicative_expression ::= multiplicative_expression slash cast_expression;
multiplicative_expression ::= multiplicative_expression percent cast_expression;
additive_expression ::= multiplicative_expression;
additive_expression ::= additive_expression plus multiplicative_expression;
additive_expression ::= additive_expression minus multiplicative_expression;
shift_expression ::= additive_expression;
shift_expression ::= shift_expression left_op additive_expression;
shift_expression ::= shift_expression right_op additive_expression;
relational_expression ::= shift_expression;
relational_expression ::= relational_expression langle shift_expression;
relational_expression ::= relational_expression rangle shift_expression;
relational_expression ::= relational_expression le_op shift_expression;
relational_expression ::= relational_expression ge_op shift_expression;
equality_expression ::= relational_expression;
equality_expression ::= equality_expression eq_op relational_expression;
equality_expression ::= equality_expression ne_op relational_expression;
AND_expression ::= equality_expression;
AND_expression ::= AND_expression ampersand equality_expression;
exclusive_OR_expression ::= AND_expression;
exclusive_OR_expression ::= exclusive_OR_expression xor AND_expression;
inclusive_OR_expression ::= exclusive_OR_expression;
inclusive_OR_expression ::= inclusive_OR_expression pipe exclusive_OR_expression;
logical_AND_expression ::= inclusive_OR_expression;
logical_AND_expression ::= logical_AND_expression and_op inclusive_OR_expression;
logical_OR_expression ::= logical_AND_expression;
logical_OR_expression ::= logical_OR_expression or_op logical_AND_expression;
conditional_expression ::= logical_OR_expression;
conditional_expression ::= logical_OR_expression question expression colon conditional_expression;
assignment_expression ::= conditional_expression;
assignment_expression ::= unary_expression assignment_operator assignment_expression;
assignment_operator ::= equal;
assignment_operator ::= mul_assign;
assignment_operator ::= div_assign;
assignment_operator ::= mod_assign;
assignment_operator ::= add_assign;
assignment_operator ::= sub_assign;
assignment_operator ::= left_assign;
assignment_operator ::= right_assign;
assignment_operator ::= and_assign;
assignment_operator ::= xor_assign;
assignment_operator ::= or_assign;
expression ::= assignment_expression;
expression ::= expression comma assignment_expression;
expression ::= error;
constant_expression ::= conditional_expression;
declaration ::= declaration_specifiers init_declarator_list_opt semicolon;
declaration ::= error;
init_declarator_list_opt ::= ;
init_declarator_list_opt ::= init_declarator_list;
declaration_specifiers ::= storage_class_specifier declaration_specifiers_opt;
declaration_specifiers ::= type_specifier declaration_specifiers_opt;
declaration_specifiers ::= type_qualifier declaration_specifiers_opt;
declaration_specifiers ::= function_specifier declaration_specifiers_opt;
declaration_specifiers_opt ::= ;
declaration_specifiers_opt ::= declaration_specifiers;
init_declarator_list ::= init_declarator;
init_declarator_list ::= init_declarator_list comma init_declarator;
init_declarator ::= declarator;
init_declarator ::= declarator equal initializer;
storage_class_specifier ::= typedef;
storage_class_specifier ::= extern_;
storage_class_specifier ::= static_;
storage_class_specifier ::= auto;
storage_class_specifier ::= register;
type_specifier ::= void;
type_specifier ::= char_;
type_specifier ::= short;
type_specifier ::= int;
type_specifier ::= long;
type_specifier ::= float;
type_specifier ::= double;
type_specifier ::= signed;
type_specifier ::= unsigned;
type_specifier ::= bool_;
type_specifier ::= complex;
type_specifier ::= imaginary;
type_specifier ::= struct_or_union_specifier;
type_specifier ::= enum_specifier;
type_specifier ::= typedef_name;
struct_or_union_specifier ::= struct_or_union identifier_opt lbrace struct_declaration_list rbrace;
struct_or_union_specifier ::= struct_or_union identifier;
identifier_opt ::= ;
identifier_opt ::= identifier;
struct_or_union ::= struct_;
struct_or_union ::= union;
struct_declaration_list ::= struct_declaration;
struct_declaration_list ::= struct_declaration_list struct_declaration;
struct_declaration ::= specifier_qualifier_list struct_declarator_list semicolon;
specifier_qualifier_list ::= type_specifier specifier_qualifier_list_opt;
specifier_qualifier_list ::= type_qualifier specifier_qualifier_list_opt;
specifier_qualifier_list_opt ::= ;
specifier_qualifier_list_opt ::= specifier_qualifier_list;
struct_declarator_list ::= struct_declarator;
struct_declarator_list ::= struct_declarator_list comma struct_declarator;
struct_declarator ::= declarator;
struct_declarator ::= declarator_opt colon constant_expression;
declarator_opt ::= ;
declarator_opt ::= declarator;
enum_specifier ::= enum_ identifier_opt lbrace enumerator_list rbrace;
enum_specifier ::= enum_ identifier_opt lbrace enumerator_list comma rbrace;
enum_specifier ::= enum_ identifier;
enumerator_list ::= enumerator;
enumerator_list ::= enumerator_list comma enumerator;
enumerator ::= enumeration_constant;
enumerator ::= enumeration_constant equal constant_expression;
type_qualifier ::= const_;
type_qualifier ::= restrict;
type_qualifier ::= volatile;
function_specifier ::= inline;
declarator ::= pointer_opt direct_declarator;
pointer_opt ::= ;
pointer_opt ::= pointer;
direct_declarator ::= identifier;
direct_declarator ::= lparen declarator rparen;
direct_declarator ::= direct_declarator lbracket type_qualifier_list_opt assignment_expression_opt rbracket;
direct_declarator ::= direct_declarator lbracket static_ type_qualifier_list_opt assignment_expression rbracket;
direct_declarator ::= direct_declarator lbracket type_qualifier_list static_ assignment_expression rbracket;
direct_declarator ::= direct_declarator lbracket type_qualifier_list_opt star rbracket;
direct_declarator ::= direct_declarator lparen parameter_type_list rparen;
direct_declarator ::= direct_declarator lparen identifier_list_opt rparen;
type_qualifier_list_opt ::= ;
type_qualifier_list_opt ::= type_qualifier_list;
identifier_list_opt ::= ;
identifier_list_opt ::= identifier_list;
pointer ::= star type_qualifier_list_opt;
pointer ::= star type_qualifier_list_opt pointer;
type_qualifier_list ::= type_qualifier;
type_qualifier_list ::= type_qualifier_list type_qualifier;
parameter_type_list ::= parameter_list;
parameter_type_list ::= parameter_list comma elipsis;
parameter_list ::= parameter_declaration;
parameter_list ::= parameter_list comma parameter_declaration;
parameter_declaration ::= declaration_specifiers declarator;
parameter_declaration ::= declaration_specifiers abstract_declarator_opt;
abstract_declarator_opt ::= ;
abstract_declarator_opt ::= abstract_declarator;
identifier_list ::= identifier;
identifier_list ::= identifier_list comma identifier;
type_name ::= specifier_qualifier_list abstract_declarator_opt;
abstract_declarator ::= pointer;
abstract_declarator ::= pointer_opt direct_abstract_declarator;
direct_abstract_declarator ::= lparen abstract_declarator rparen;
direct_abstract_declarator ::= direct_abstract_declarator_opt lbracket assignment_expression_opt rbracket;
direct_abstract_declarator ::= direct_abstract_declarator_opt lbracket star rbracket;
direct_abstract_declarator ::= direct_abstract_declarator_opt lparen parameter_type_list_opt rparen;
direct_abstract_declarator_opt ::= ;
direct_abstract_declarator_opt ::= direct_abstract_declarator;
assignment_expression_opt ::= ;
assignment_expression_opt ::= assignment_expression;
parameter_type_list_opt ::= ;
parameter_type_list_opt ::= parameter_type_list;
typedef_name ::= identifier;
initializer ::= assignment_expression;
initializer ::= lbrace initializer_list rbrace;
initializer ::= lbrace initializer_list comma rbrace;
initializer_list ::= designation_opt initializer;
initializer_list ::= initializer_list comma designation_opt initializer;
designation_opt ::= ;
designation_opt ::= designation;
designation ::= designator_list equal;
designator_list ::= designator;
designator_list ::= designator_list designator;
designator ::= rbracket constant_expression rbracket;
designator ::= dot identifier;
statement ::= labeled_statement;
statement ::= compound_statement;
statement ::= expression_statement;
statement ::= selection_statement;
statement ::= iteration_statement;
statement ::= jump_statement;
statement ::= error;
labeled_statement ::= identifier colon statement;
labeled_statement ::= case constant_expression colon statement;
labeled_statement ::= default colon statement;
compound_statement ::= lbrace block_item_list_opt rbrace;
block_item_list_opt ::= ;
block_item_list_opt ::= block_item_list;
block_item_list ::= block_item;
block_item_list ::= block_item_list block_item;
block_item ::= declaration;
block_item ::= statement;
expression_statement ::= expression_opt semicolon;
expression_opt ::= ;
expression_opt ::= expression;
selection_statement ::= if_ lparen expression rparen statement;
selection_statement ::= if_ lparen expression rparen statement else_ statement;
selection_statement ::= switch lparen expression rparen statement;
iteration_statement ::= while_ lparen expression rparen statement;
iteration_statement ::= do_ statement while_ lparen expression rparen semicolon;
iteration_statement ::= for_ lparen expression_opt semicolon expression_opt semicolon expression_opt rparen statement;
iteration_statement ::= for_ lparen declaration expression_opt semicolon expression_opt rparen statement;
jump_statement ::= goto identifier semicolon;
jump_statement ::= continue_ semicolon;
jump_statement ::= break_ semicolon;
jump_statement ::= return_ expression_opt semicolon;
translation_unit ::= external_declaration;
translation_unit ::= translation_unit external_declaration;
external_declaration ::= function_definition;
external_declaration ::= declaration;
function_definition ::= declaration_specifiers declarator declaration_list_opt compound_statement;
declaration_list_opt ::= ;
declaration_list_opt ::= declaration_list;
declaration_list ::= declaration;
declaration_list ::= declaration_list declaration;
enumeration_constant ::= identifier;
    "##).expect("could not load grammar")
}
